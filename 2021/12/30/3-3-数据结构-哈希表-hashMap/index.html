

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Thomas Yuan">
  <meta name="keywords" content="">
  
    <meta name="description" content="3.3 哈希表 hashMap数组 &#x2F; 切片 -&gt; 表示 元素 的序列 hashMap -&gt; 表示 键值对 之间的 映射 关系 3.3.1 设计原理读写 hashMap 的时间复杂度：O(1)，要想实现一个性能优异的哈希表，需要解决：哈希函数 hash Function、冲突解决方法 哈希函数 hash Function理想的 hash Function：能够将不同的 键 key 映射">
<meta property="og:type" content="article">
<meta property="og:title" content="3.3 数据结构 -- 哈希表 hashMap">
<meta property="og:url" content="http://example.com/2021/12/30/3-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8-hashMap/index.html">
<meta property="og:site_name" content="Gopher Thomas">
<meta property="og:description" content="3.3 哈希表 hashMap数组 &#x2F; 切片 -&gt; 表示 元素 的序列 hashMap -&gt; 表示 键值对 之间的 映射 关系 3.3.1 设计原理读写 hashMap 的时间复杂度：O(1)，要想实现一个性能优异的哈希表，需要解决：哈希函数 hash Function、冲突解决方法 哈希函数 hash Function理想的 hash Function：能够将不同的 键 key 映射">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2021/12/30/3-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8-hashMap/hmap-and-buckets.png">
<meta property="og:image" content="https://note.youdao.com/yws/api/group/102464226/file/911384549?method=download&inline=true&version=1&shareToken=E35BF92B0016438D8E822489C97315FD">
<meta property="article:published_time" content="2021-12-30T15:45:23.000Z">
<meta property="article:modified_time" content="2021-12-30T15:48:32.828Z">
<meta property="article:author" content="Thomas Yuan">
<meta property="article:tag" content="《Go语言设计与实现》">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://example.com/2021/12/30/3-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8-hashMap/hmap-and-buckets.png">
  
  
  <title>3.3 数据结构 -- 哈希表 hashMap - Gopher Thomas</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.13","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"0SrF373pw8HzuOT402REPdE9-gzGzoHsz","app_key":"PijYR5FjJEAiikcHPtF712qM","server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>TY 札记</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="3.3 数据结构 -- 哈希表 hashMap">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-30 23:45" pubdate>
        2021年12月30日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      28k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      237 分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">3.3 数据结构 -- 哈希表 hashMap</h1>
            
            <div class="markdown-body">
              <h2><span id="33-哈希表-hashmap">3.3 哈希表 hashMap</span></h2><p>数组 / 切片 -&gt; 表示 元素 的序列</p>
<p><code>hashMap</code> -&gt; 表示 键值对 之间的 映射 关系</p>
<h3><span id="331-设计原理">3.3.1 设计原理</span></h3><p>读写 hashMap 的时间复杂度：O(1)，要想实现一个性能优异的哈希表，需要解决：哈希函数 hash Function、冲突解决方法</p>
<h4><span id="哈希函数-hash-function">哈希函数 hash Function</span></h4><p>理想的 hash Function：能够将不同的 键 key 映射到不同的索引上，这要求 hash Function 的输出范围 大于 输入的范围（实际情况下不可能实现）。</p>
<p>不均匀 hash Function：让 hash Function 的结果，尽可能的均匀分布，通过工程上的手段解决 hash reflect。</p>
<p>hash Function 的选定，对 hashMap 性能的影响较大。</p>
<h4><span id="冲突解决-开放寻址-拉链法">冲突解决 – 开放寻址、拉链法</span></h4><p>多数的 hash Function 都是不够完美的 -&gt; hash reflect</p>
<p>常见的解决 hash reflect 的方法：开放寻址法、拉链法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">需要注意的是，我们在这里提到的 <span class="hljs-built_in">hash</span> reflect 不是多个 键(key) 的 <span class="hljs-built_in">hash</span> 完全相等<br>可能是多个 <span class="hljs-built_in">hash</span> 的 部分相等<br>如：两个键对应 <span class="hljs-built_in">hash</span> 的前四个字节相同<br></code></pre></td></tr></table></figure>

<p><strong>开放寻址法</strong><br>核心思想：依次 探测、比较 <strong>数组</strong> 中的元素，以判断目标键值对是否存在于 哈希表中</p>
<p>对应的底层数据结构是 数组</p>
<p>对应的 hash 函数可能为：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> hash(<span class="hljs-string">&quot;key&quot;</span>) -&gt; 将 字符串 转化为 数字<br><span class="hljs-regexp">//</span> hash(<span class="hljs-string">&quot;key&quot;</span>) % array.len -&gt; 对 数组长度 取 余数<br>index := hash(<span class="hljs-string">&quot;key&quot;</span>) % array.len<br></code></pre></td></tr></table></figure>

<p>如果出现 hash reflect，就会向后 依次探测，找到下一个 索引不为空 的位置。</p>
<p>这种较为简单的机制，会导致在 访问 hashMap 时，产生多余的读取次数，降低性能。</p>
<p>对性能影响最大的参数为：装载因子 load factor，其计算方法为：数组中元素的数量 / 数组大小</p>
<p>随着 load factor 的增加，线性探测的平均用时就会逐渐增加。</p>
<p>load factor = 100% 时，hashMap 失效。查找 和 插入元素的时间复杂度都是 O(n)，需要遍历数组中的全部元素。</p>
<p><strong>拉链法</strong><br>数组 + 链表 实现，有的编程语言会在 拉链法 的 hash 中，引入 红黑树 来优化性能。</p>
<p>数组 实际上对应到具体的桶 bucket，同一个 桶 的数据 存储在一个链表中。</p>
<p>拉链法 写入 hashMap 时，也是有一个 hash Function 的存在（此处使用了 对数组的长度取余）：</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs n1ql">// <span class="hljs-keyword">index</span> -&gt; 当前元素所在的 桶(<span class="hljs-keyword">bucket</span>) 的序号<br><span class="hljs-keyword">index</span> := hash(<span class="hljs-string">&quot;key&quot;</span>) % <span class="hljs-keyword">array</span>.len<br></code></pre></td></tr></table></figure>

<p>在定位到其所在的桶后，需要遍历 对应的链表，可能遇到以下情况：</p>
<ol>
<li>找到 键 相同的键值对 -&gt; 更新键对应的值</li>
<li>未找到 键 相同的键值对 -&gt; 在链表的末尾追加新的键值对</li>
</ol>
<p>读写 hashMap 的主要开销：计算 hash value、定位桶、遍历链表。</p>
<p>拉链法的 <strong>load factor</strong> = 元素数量 / 桶数量</p>
<p>load factor 越大，hashMap 的读写性能越差。在一般情况下，拉链法的 load factor &lt;= 1</p>
<p>当 load factor 较大时，会触发 hashMap 的 扩容，创建更多的桶来存储更多的 元素（<strong>具体要看语言的实现</strong>）。</p>
<h3><span id="332-数据结构">3.3.2 数据结构</span></h3><p>编译期间的 hashMap 是 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/3b2a578166bdedd94110698c971ba8990771eb89/src/cmd/compile/internal/types/type.go#L217">src/cmd/compile/internal/types.Map</a> 类型的，通过 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/f5978a09589badb927d3aa96998fc785524cae02/src/cmd/compile/internal/types/type.go#L536">src/cmd/compile/internal/types.NewMap()</a> 对其进行初始化：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ada">// types.Map<br>// Map contains <span class="hljs-keyword">Type</span> <span class="hljs-type">fields </span>specific to maps.<br><span class="hljs-keyword">type</span> <span class="hljs-type">Map </span>struct &#123;<br>	Key  *<span class="hljs-keyword">Type</span> <span class="hljs-type">// </span>Key <span class="hljs-keyword">type</span><br>	<span class="hljs-type">Elem </span>*<span class="hljs-keyword">Type</span> <span class="hljs-type">// </span>Val (elem) <span class="hljs-keyword">type</span><br><br>	<span class="hljs-type">Bucket </span>*<span class="hljs-keyword">Type</span> <span class="hljs-type">// </span>internal struct <span class="hljs-keyword">type</span> <span class="hljs-type">representing </span>a hash bucket<br>	Hmap   *<span class="hljs-keyword">Type</span> <span class="hljs-type">// </span>internal struct <span class="hljs-keyword">type</span> <span class="hljs-type">representing </span>the Hmap (map header object)<br>	Hiter  *<span class="hljs-keyword">Type</span> <span class="hljs-type">// </span>internal struct <span class="hljs-keyword">type</span> <span class="hljs-type">representing </span>hash iterator state<br>&#125;<br><br>// func NewMap()<br>// NewMap returns a <span class="hljs-keyword">new</span> map <span class="hljs-keyword">Type</span> <span class="hljs-type">with </span>key <span class="hljs-keyword">type</span> <span class="hljs-type">k </span><span class="hljs-keyword">and</span> element (aka value) <span class="hljs-keyword">type</span> <span class="hljs-type">v.</span><br><span class="hljs-type"></span>func NewMap(k, v *<span class="hljs-keyword">Type</span>) *<span class="hljs-keyword">Type</span> <span class="hljs-type">&#123;</span><br><span class="hljs-type">	</span>t := <span class="hljs-keyword">New</span>(TMAP)<br>	mt := t.MapType()<br>	mt.Key = k<br>	mt.Elem = v<br>	<span class="hljs-keyword">return</span> t<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在 运行时 runtime，使用了多个数据结构的组合表示 hashMap，<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/runtime/map.go#L115">runtime.hmap</a> 是最核心的结构体：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runtime.hmap</span><br><span class="hljs-comment">// A header for a Go map.</span><br><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.</span><br>	<span class="hljs-comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span><br>	count     <span class="hljs-keyword">int</span> <span class="hljs-comment">// # live cells == size of map.  Must be first (used by len() builtin)</span><br>	flags     <span class="hljs-keyword">uint8</span><br>	B         <span class="hljs-keyword">uint8</span>  <span class="hljs-comment">// log_2 of # of buckets (can hold up to loadFactor * 2^B items)</span><br>	noverflow <span class="hljs-keyword">uint16</span> <span class="hljs-comment">// approximate number of overflow buckets; see incrnoverflow for details</span><br>	hash0     <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// hash seed</span><br><br>	buckets    unsafe.Pointer <span class="hljs-comment">// array of 2^B Buckets. may be nil if count==0.</span><br>	oldbuckets unsafe.Pointer <span class="hljs-comment">// previous bucket array of half the size, non-nil only when growing</span><br>	nevacuate  <span class="hljs-keyword">uintptr</span>        <span class="hljs-comment">// progress counter for evacuation (buckets less than this have been evacuated)</span><br><br>	extra *mapextra <span class="hljs-comment">// optional fields</span><br>&#125;<br><br><span class="hljs-comment">// runtime.mapextra</span><br><span class="hljs-comment">// mapextra holds fields that are not present on all maps.</span><br><span class="hljs-keyword">type</span> mapextra <span class="hljs-keyword">struct</span> &#123;<br>	<span class="hljs-comment">// If both key and elem do not contain pointers and are inline, then we mark bucket</span><br>	<span class="hljs-comment">// type as containing no pointers. This avoids scanning such maps.</span><br>	<span class="hljs-comment">// However, bmap.overflow is a pointer. In order to keep overflow buckets</span><br>	<span class="hljs-comment">// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.</span><br>	<span class="hljs-comment">// overflow and oldoverflow are only used if key and elem do not contain pointers.</span><br>	<span class="hljs-comment">// overflow contains overflow buckets for hmap.buckets.</span><br>	<span class="hljs-comment">// oldoverflow contains overflow buckets for hmap.oldbuckets.</span><br>	<span class="hljs-comment">// The indirection allows to store a pointer to the slice in hiter.</span><br>	overflow    *[]*bmap<br>	oldoverflow *[]*bmap<br>    <br>	<span class="hljs-comment">// nextOverflow holds a pointer to a free overflow bucket.</span><br>	nextOverflow *bmap<br>&#125;<br><br><span class="hljs-comment">// runtime.bmap</span><br><span class="hljs-comment">// A bucket for a Go map.</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>	tophash [bucketCnt]<span class="hljs-keyword">uint8</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>结构体中的字段：</p>
<ol>
<li>count -&gt; 当前 hashMap 中的 元素数量</li>
<li>B -&gt; 表示当前 hashMap 使用到的 buckets 数量，buckets = 2^B; B = log(buckets)</li>
<li>noverflow -&gt; overflow buckets 溢出桶的数量</li>
<li>hash0 -&gt; hash seed 哈希种子，为 hash Function 引入了随机性，这个值在创建 hashMap 时确定，并在 hash() 时作为参数传入</li>
<li>buckets -&gt; 桶，对应到的数据结构为： <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L149">runtime.bmap</a></li>
<li>oldbuckets -&gt; 在扩容时使用，用于保存旧 hashMap 的 buckets 字段，大小为当前 buckets 的一半（扩容的时候翻倍了）</li>
<li>nevacuate -&gt; 用于 分流 旧桶 中的数据</li>
<li>extra -&gt; 存储 溢出 bucket 的数据，对应到的数据结构为： <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L132">runtime.mapextra</a></li>
</ol>
<p>具体可参考下图：</p>
<img src="/2021/12/30/3-3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%93%88%E5%B8%8C%E8%A1%A8-hashMap/hmap-and-buckets.png" srcset="/img/loading.gif" lazyload class title="hmap 和 buckets 之间的关系">

<p><img src="https://note.youdao.com/yws/api/group/102464226/file/911384549?method=download&inline=true&version=1&shareToken=E35BF92B0016438D8E822489C97315FD" srcset="/img/loading.gif" lazyload alt="image"></p>
<p>runtime.hmap 的桶是 runtime.bmap。每一个 runtime.bmap 都能存储 8 个键值对，当 hashMap 中存储的数据过多时，单个桶已经装满时，会使用 extra.nextOverflow 中的桶存储溢出的数据。</p>
<p>上图中，黄色的部分为 正常桶，绿色的部分为 溢出桶（溢出桶是在 Golang 使用 C 实现时使用的设计，由于它能减少扩容的频率，所以被保留到现在）。</p>
<h4><span id="runtimebmap">runtime.bmap</span></h4><p>桶的结构体 runtime.bmap，看起来实现较为简单，只包含了一个简单的 tophash 字段。</p>
<p>tophash 字段，用于存储键的 hash 的高 8 位，通过比较不同键的 hash 的高 8 位，减少了访问键值对次数，提高了性能。</p>
<p>tophash 只能用于存储 hash 的 top 8 位，并不能去表示 buckets 中需要存储的 不同类型的 key-value 数据。这一阶段实际上是在编译期间进行的，golang compile 需要在编译时推导出 buckets 中存储的 键值对 的类型 以及其 占用的内存空间大小。</p>
<p>++在运行期间， runtime.bmap 结构体不止包含 tophash 字段，考虑到哈希表中可能存储不同类型的键值对（key-value 的类型多种多样），而且 1.x 版本的 Golang 并未添加对泛型的支持，所以键值对的类型以及其所占内存大小只能在编译时进行推导。++</p>
<p>这一过程包含在编译器间的函数 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/cmd/compile/internal/gc/reflect.go#L83">src/cmd/compile/internal/gc.bmap()</a> 中；runtime.bmap 中的其他字段在运行时，是通过计算内存地址的方式访问的，在定义中没有包含这些字段。</p>
<p>我们可以通过这个函数，重建出 runtime.bmap 在运行时中的结构：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 运行期间的结构 -- 通过 src<span class="hljs-regexp">/cmd/</span>compile<span class="hljs-regexp">/internal/g</span>c/reflect.go Line <span class="hljs-number">83</span> 可以重建其结构<br>type bmap struct &#123;<br>    topbits  [<span class="hljs-number">8</span>]uint8       <span class="hljs-regexp">//</span> 存储 Hash 高 <span class="hljs-number">8</span> 位，每个桶存储 <span class="hljs-number">8</span> 个 -&gt; <span class="hljs-number">8</span> 个键值对<br>    keys     [<span class="hljs-number">8</span>]keytype     <span class="hljs-regexp">//</span> 存储 key 值<br>    values   [<span class="hljs-number">8</span>]valuetype   <span class="hljs-regexp">//</span> Key 值对应的 value<br>    pad      uintptr        <br>    overflow uintptr        <span class="hljs-regexp">//</span> 指向溢出 bucket 的地址（链地址法解决 key 冲突）<br>&#125;<br></code></pre></td></tr></table></figure>

<p>gc.bmap() 函数源码如下：</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs elm">// bmap makes the map bucket <span class="hljs-keyword">type</span> given the <span class="hljs-keyword">type</span> of the map.<br><span class="hljs-title">func</span> bmap(t *types.<span class="hljs-type">Type</span>) *types.<span class="hljs-type">Type</span> &#123;<br>    // <span class="hljs-type">Step1</span>: 检查当前 <span class="hljs-type">Map</span> 的 <span class="hljs-type">Bucket</span> 是否为空<br>	if t.<span class="hljs-type">MapType</span>().<span class="hljs-type">Bucket</span> != nil &#123;<br>		return t.<span class="hljs-type">MapType</span>().<span class="hljs-type">Bucket</span><br>	&#125;<br><br>    // <span class="hljs-type">Step2</span>: 初始化 bucket，类型推断 获得 key<span class="hljs-keyword">type</span>，elemtype，同时确保 keytype 以及 elemtype 大小合理<br>    // 这里传入的参数是：<span class="hljs-type">TSTRUCT</span> -&gt; 在 <span class="hljs-type">Type</span>.go 中，<span class="hljs-type">TSTRUCT</span> : *<span class="hljs-type">Struct</span><br>	bucket := types.<span class="hljs-type">New</span>(<span class="hljs-type">TSTRUCT</span>)<br>	// 通过 <span class="hljs-type">Type</span>.<span class="hljs-type">Key</span>() 获取 map 中 key 的类型<br>	key<span class="hljs-keyword">type</span> := t.<span class="hljs-type">Key</span>()<br>	// 通过 <span class="hljs-type">Type</span>.<span class="hljs-type">Elem</span>() 获取 map 中 value 的类型<br>	elem<span class="hljs-keyword">type</span> := t.<span class="hljs-type">Elem</span>()<br>	dowidth(key<span class="hljs-keyword">type</span>)<br>	dowidth(elem<span class="hljs-keyword">type</span>)<br>	// key<span class="hljs-keyword">type</span>, elemtype 大小检测<br>	<span class="hljs-keyword">if</span> key<span class="hljs-keyword">type</span>.<span class="hljs-type">Width</span> &gt; <span class="hljs-type">MAXKEYSIZE</span> &#123;<br>		keytype = types.<span class="hljs-type">NewPtr(keytype)</span><br>	&#125;<br>	<span class="hljs-keyword">if</span> elem<span class="hljs-keyword">type</span>.<span class="hljs-type">Width</span> &gt; <span class="hljs-type">MAXELEMSIZE</span> &#123;<br>		elemtype = types.<span class="hljs-type">NewPtr(elemtype)</span><br>	&#125;<br>    <br>    // <span class="hljs-type">Step3</span>: 初始化 bmap 中包含的字段，对 bmap 进行重组<br>    // 使用的切片，切片大小 = <span class="hljs-number">5</span><br>	field := make([]*types.<span class="hljs-type">Field</span>, 0, 5)<br><br>	// <span class="hljs-type">The</span> first field is: uint8 topbits[<span class="hljs-type">BUCKETSIZE</span>].<br>	// 第一个字段：topbits [<span class="hljs-type">BUCKETSIZE</span>] uint8 <span class="hljs-comment">-- 对应到 tophash</span><br>	arr := types.<span class="hljs-type">NewArray</span>(types.<span class="hljs-type">Types</span>[<span class="hljs-type">TUINT8</span>], <span class="hljs-type">BUCKETSIZE</span>)<br>	field = append(field, makefield(<span class="hljs-string">&quot;topbits&quot;</span>, arr))<br><br>    // 第二个字段：keys [<span class="hljs-type">BUCKETSIZE</span>] key<span class="hljs-keyword">type</span>，存储的是 key 的集合<br>	arr = types.<span class="hljs-type">NewArray</span>(keytype, <span class="hljs-type">BUCKETSIZE</span>)<br>	arr.<span class="hljs-type">SetNoalg</span>(true)<br>	keys := makefield(<span class="hljs-string">&quot;keys&quot;</span>, arr)<br>	field = append(field, keys)<br>    <br>    // 第三个字段：elems [<span class="hljs-type">BUCKETSIZE</span>] elem<span class="hljs-keyword">type</span>，存储的是 value 的集合<br>	arr = types.<span class="hljs-type">NewArray</span>(elemtype, <span class="hljs-type">BUCKETSIZE</span>)<br>	arr.<span class="hljs-type">SetNoalg</span>(true)<br>	elems := makefield(<span class="hljs-string">&quot;elems&quot;</span>, arr)<br>	field = append(field, elems)<br>    <br>    ...<br>    <br>	// 第四个字段: overflow uintptr，存储指向溢出桶的指针<br>	otyp := types.<span class="hljs-type">NewPtr</span>(bucket)<br>	<span class="hljs-keyword">if</span> !elem<span class="hljs-keyword">type</span>.<span class="hljs-type">HasPointers</span>() &amp;&amp; !keytype.<span class="hljs-type">HasPointers</span>() &#123;<br>		otyp = types.<span class="hljs-type">Types</span>[<span class="hljs-type">TUINTPTR</span>]<br>	&#125;<br>	overflow := makefield(<span class="hljs-string">&quot;overflow&quot;</span>, otyp)<br>	field = append(field, overflow)<br><br>	// link up fields<br>	// 字段重组: bucket 本质上是一个结构体，这里使用了 struct 的 setFields()，用于设定 bucket 中的字段<br>	bucket.<span class="hljs-type">SetNoalg</span>(true)<br>	bucket.<span class="hljs-type">SetFields</span>(field[:])<br>	dowidth(bucket)<br><br>	// <span class="hljs-type">Check</span> invariants that map code depends on.<br>	<span class="hljs-keyword">if</span> !<span class="hljs-type">IsComparable</span>(t.<span class="hljs-type">Key</span>()) &#123;<br>		<span class="hljs-type">Fatalf</span>(<span class="hljs-string">&quot;unsupported map key type for %v&quot;</span>, t)<br>	&#125;<br>	<span class="hljs-keyword">if</span> <span class="hljs-type">BUCKETSIZE</span> &lt; <span class="hljs-number">8</span> &#123;<br>		<span class="hljs-type">Fatalf</span>(<span class="hljs-string">&quot;bucket size too small for proper alignment&quot;</span>)<br>	&#125;<br>	<span class="hljs-keyword">if</span> key<span class="hljs-keyword">type</span>.<span class="hljs-type">Align</span> &gt; <span class="hljs-type">BUCKETSIZE</span> &#123;<br>		<span class="hljs-type">Fatalf</span>(&quot;key align too big for %v&quot;, t)<br>	&#125;<br>	<span class="hljs-keyword">if</span> elem<span class="hljs-keyword">type</span>.<span class="hljs-type">Align</span> &gt; <span class="hljs-type">BUCKETSIZE</span> &#123;<br>		<span class="hljs-type">Fatalf</span>(&quot;elem align too big for %v&quot;, t)<br>	&#125;<br>	<br>    ...<br>    ...<br> <br>	// <span class="hljs-type">Double</span>-check that overflow field is final memory <span class="hljs-keyword">in</span> struct,<br>	// with no padding at end.<br>	<span class="hljs-keyword">if</span> overflow.<span class="hljs-type">Offset</span> != bucket.<span class="hljs-type">Width</span>-int64(<span class="hljs-type">Widthptr</span>) &#123;<br>		<span class="hljs-type">Fatalf</span>(<span class="hljs-string">&quot;bad offset of overflow in bmap for %v&quot;</span>, t)<br>	&#125;<br>    // <span class="hljs-type">Step4</span>: 检查 构建 bmap 使用的 不变量，如：<span class="hljs-type">BUCKETSIZE</span>，key<span class="hljs-keyword">type</span>，elemtype，keyType.align等<br>    // 对 overflow 字段做二次检查，确保 overflow 是最后添加到结构体中的，且不存在字节冗余（考虑性能）<br>    // 最后对 bucket 进行类型重组，返回<br>	t.<span class="hljs-type">MapType</span>().<span class="hljs-type">Bucket</span> = bucket<br><br>    // 类型重组<br>	bucket.<span class="hljs-type">StructType</span>().<span class="hljs-type">Map</span> = t<br>	return bucket<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由上述代码可以看出，在 编译期间 对 bmap 的重建，主要分为以下 4 步：</p>
<ol>
<li>检查当前 Map 的 Bucket 是否为空，如果不为空，直接返回（需要进行不为空检查）;</li>
<li>初始化 bucket，类型推断 获得 keytype, elemtype，同时确保 keytype 以及 elemtype; 大小合理;</li>
<li>初始化 bmap 中包含的字段，对 bmap 进行重组;</li>
<li>检查构建 bmap 使用的不变：BUCKETSIZE, keytype, elemtype, keytype.align 等，同时二次检查 overflow 字段，确保 overflow 最后添加到结构体中，且不存在字节冗余；最后对 bucket 进行类型重组，返回</li>
</ol>
<h3><span id="333-初始化">3.3.3 初始化</span></h3><h4><span id="字面量">字面量</span></h4><p>字面量初始化 使用 key: value 的语法来表示键值对：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">hash := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;<br>    <span class="hljs-string">&quot;1&quot;</span> : <span class="hljs-number">2</span>,<br>    <span class="hljs-string">&quot;3&quot;</span> : <span class="hljs-number">4</span>,<br>    <span class="hljs-string">&quot;5&quot;</span> : <span class="hljs-number">6</span>,<br>&#125;<br></code></pre></td></tr></table></figure>

<p>字面量声明方式 通过 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/cmd/compile/internal/gc/sinit.go#L753">src/cmd/compile/internal/gc.maplit()</a> 函数，在编译期间完成初始化：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">maplit</span><span class="hljs-params">(n *Node, m *Node, init *Nodes)</span></span> &#123;<br>	<span class="hljs-comment">// make the map var</span><br>	<span class="hljs-comment">// 节点转换为 OMAKE 节点 -&gt; 实际调用为 makemap()</span><br>	a := nod(OMAKE, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>)<br>	a.Esc = n.Esc<br>	a.List.Set2(typenod(n.Type), nodintconst(<span class="hljs-keyword">int64</span>(n.List.Len())))<br>	litas(m, a, init)<br><br>	entries := n.List.Slice()<br><br>	<span class="hljs-comment">// The order pass already removed any dynamic (runtime-computed) entries.</span><br>	<span class="hljs-comment">// All remaining entries are static. Double-check that.</span><br>	<span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> entries &#123;<br>		<span class="hljs-keyword">if</span> !isStaticCompositeLiteral(r.Left) || !isStaticCompositeLiteral(r.Right) &#123;<br>			Fatalf(<span class="hljs-string">&quot;maplit: entry is not a literal: %v&quot;</span>, r)<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(entries) &gt; <span class="hljs-number">25</span> &#123;<br>		<span class="hljs-comment">// For a large number of entries, put them in an array and loop.</span><br>		<span class="hljs-comment">// build types [count]Tindex and [count]Tvalue</span><br>        ...<br>		<span class="hljs-keyword">return</span><br>	&#125;<br>	<span class="hljs-comment">// For a small number of entries, just add them directly.</span><br>	<br>	<span class="hljs-comment">// Build list of var[c] = expr.</span><br>	<span class="hljs-comment">// Use temporaries so that mapassign1 can have addressable key, elem.</span><br>	<span class="hljs-comment">// TODO(josharian): avoid map key temporaries for mapfast_* assignments with literal keys.</span><br>	...<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由代码可以看出，Map 字面量初始化逻辑为：</p>
<ol>
<li>当 hashMap 中元素数量 大于 25 时，编译器会创建两个数组，分别存储 key 和 value，这些 key 和 value 会通过一个 for loop 循环加入到 hashMap<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Sample code</span><br><span class="hljs-comment">// 实际使用 make() 创建 hashMap</span><br>hashMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>, <span class="hljs-number">26</span>)<br><br><span class="hljs-comment">// 实际执行逻辑</span><br>vstatk := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, ..., <span class="hljs-string">&quot;26&quot;</span>&#125;<br>vstatv := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ..., <span class="hljs-number">26</span>&#125;<br><span class="hljs-comment">// for loop</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(vstatk); i++ &#123;<br>    hashMap[ vstatk[i] ] = vstatv[i]   <br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>当 hashMap 中的元素数量 &lt;= 25 时，将所有的键值对，一次性加入到 hashMap 中。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Sample code</span><br><span class="hljs-comment">// 实际使用 make() 创建 hashMap</span><br>hashMap := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// 实际执行逻辑</span><br>hashMap[<span class="hljs-string">&quot;1&quot;</span>] = <span class="hljs-number">2</span><br>hashMap[<span class="hljs-string">&quot;3&quot;</span>] = <span class="hljs-number">4</span><br>hashMap[<span class="hljs-string">&quot;5&quot;</span>] = <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure></li>
</ol>
<p>在使用字面量方式 初始化 hashMap 时，使用到的还是 make() 初始化 hashMap；通过判断元素的数量 使用 for-loop 或者 直接写入 的方式，填充 hashMap</p>
<p>与 数组、切片 的字面量初始化方式相同，hashMap 的字面量初始化 也是 golang 提供的辅助工具，最后调用的都是 makeslice(), makemap()</p>
<h4><span id="运行时-make-gt-makemap">运行时 – make() -&gt; makemap(){}</span></h4><p>一种特殊的情况是：hashMap 被分配到栈上，且容量小于 BUCKETSIZE = 8时，golang compile 会使用以下方式 快速初始化 hashMap -&gt; 编译器对小容量的 hashMap 的优化</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// hmap</span><br><span class="hljs-selector-tag">var</span> h *hmap<br><span class="hljs-selector-tag">var</span> hv hmap<br><span class="hljs-comment">// bucket</span><br><span class="hljs-selector-tag">var</span> bv bmap<br>h := &amp;hv<br><span class="hljs-selector-tag">b</span> := &amp;bv<br><span class="hljs-comment">// 快速初始化 buckets</span><br>h<span class="hljs-selector-class">.buckets</span> = <span class="hljs-selector-tag">b</span><br><span class="hljs-comment">// 随机 hash seed</span><br>h<span class="hljs-selector-class">.hash0</span> = fashtrand0()<br></code></pre></td></tr></table></figure>

<p>对于字面量、make() 等情况，使用 make 关键字创建 hashMap 时，golang compile 都在 类型检查期间将其转换为 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L303">runtime.makemap()</a></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// func makemap()</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makemap</span><span class="hljs-params">(t *maptype, hint <span class="hljs-keyword">int</span>, h *hmap)</span> *<span class="hljs-title">hmap</span></span> &#123;<br>    <span class="hljs-comment">// 1. 计算 hash 占用的内存是否溢出 or 超出了能分配的最大值</span><br>	mem, overflow := math.MulUintptr(<span class="hljs-keyword">uintptr</span>(hint), t.bucket.size)<br>	<span class="hljs-keyword">if</span> overflow || mem &gt; maxAlloc &#123;<br>		hint = <span class="hljs-number">0</span><br>	&#125;<br><br>	<span class="hljs-comment">// initialize Hmap</span><br>	<span class="hljs-keyword">if</span> h == <span class="hljs-literal">nil</span> &#123;<br>		h = <span class="hljs-built_in">new</span>(hmap)<br>	&#125;<br>	<span class="hljs-comment">// 2. 获取随机 hash seed</span><br>	h.hash0 = fastrand()<br><br>	<span class="hljs-comment">// Find the size parameter B which will hold the requested # of elements.</span><br>	<span class="hljs-comment">// For hint &lt; 0 overLoadFactor returns false since hint &lt; bucketCnt.</span><br>	B := <span class="hljs-keyword">uint8</span>(<span class="hljs-number">0</span>)<br>	<span class="hljs-comment">// 3. 根据 hint 计算出 最小需要的 bucket 的数量</span><br>	<span class="hljs-keyword">for</span> overLoadFactor(hint, B) &#123;<br>		B++<br>	&#125;<br>	h.B = B<br>    <br>    <span class="hljs-comment">// 4. 调用 runtime.makeBucketArray() 创建用于保存 桶 的数组</span><br>	<span class="hljs-comment">// allocate initial hash table</span><br>	<span class="hljs-comment">// if B == 0, the buckets field is allocated lazily later (in mapassign)</span><br>	<span class="hljs-comment">// If hint is large zeroing this memory could take a while.</span><br>	<span class="hljs-keyword">if</span> h.B != <span class="hljs-number">0</span> &#123;<br>		<span class="hljs-keyword">var</span> nextOverflow *bmap<br>		h.buckets, nextOverflow = makeBucketArray(t, h.B, <span class="hljs-literal">nil</span>)<br>		<span class="hljs-keyword">if</span> nextOverflow != <span class="hljs-literal">nil</span> &#123;<br>			h.extra = <span class="hljs-built_in">new</span>(mapextra)<br>			h.extra.nextOverflow = nextOverflow<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> h<br>&#125;<br></code></pre></td></tr></table></figure>

<p>函数的执行步骤如下：</p>
<ol>
<li>计算哈希占用的内存是否溢出或者超出能分配的最大值；</li>
<li>调用 runtime.fastrand 获取一个随机的哈希种子；</li>
<li>根据传入的 hint 计算出需要的最小需要的桶的数量；</li>
<li>使用 runtime.makeBucketArray 创建用于保存桶的数组</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L344">runtime.makeBucketArray()</a> 根据传入的 B，计算出需要创建的 Bucket 的数量 并在内存中分配一片连续的空间用于存储数据：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeBucketArray</span><span class="hljs-params">(t *maptype, b <span class="hljs-keyword">uint8</span>, dirtyalloc unsafe.Pointer)</span> <span class="hljs-params">(buckets unsafe.Pointer, nextOverflow *bmap)</span></span> &#123;<br>	base := bucketShift(b)<br>	nbuckets := base<br>	<span class="hljs-comment">// B &gt; 4 需要创建 溢出桶</span><br>	<span class="hljs-keyword">if</span> b &gt;= <span class="hljs-number">4</span> &#123;<br>	    <span class="hljs-comment">// 额外创建了 2^(B - 4) 个溢出桶</span><br>		nbuckets += bucketShift(b - <span class="hljs-number">4</span>)<br>		sz := t.bucket.size * nbuckets<br>		up := roundupsize(sz)<br>		<span class="hljs-keyword">if</span> up != sz &#123;<br>			nbuckets = up / t.bucket.size<br>		&#125;<br>	&#125;<br>    <span class="hljs-comment">// B &lt; 4，直接创建 2^B 个 bucket</span><br>    <span class="hljs-comment">// 调用 types.newarray() 创建数组</span><br>	buckets = newarray(t.bucket, <span class="hljs-keyword">int</span>(nbuckets))<br>	<span class="hljs-comment">// 溢出桶 处理逻辑</span><br>	<span class="hljs-keyword">if</span> base != nbuckets &#123;<br>	    <span class="hljs-comment">// 指定出 溢出桶的位置</span><br>		nextOverflow = (*bmap)(add(buckets, base*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>		<span class="hljs-comment">// 溢出桶 末尾位置</span><br>		last := (*bmap)(add(buckets, (nbuckets<span class="hljs-number">-1</span>)*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>		last.setoverflow(t, (*bmap)(buckets))<br>	&#125;<br>	<span class="hljs-keyword">return</span> buckets, nextOverflow<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在函数内根据 B 的值，进入到两种处理逻辑：</p>
<ol>
<li>B &lt; 4，数据较少、使用溢出桶的可能性较低，会省去创建的过程以减少额外的开销</li>
<li>B &gt;= 4，额外创建 2^(B - 4) 个溢出桶</li>
</ol>
<p>在正常情况下，正常桶和溢出桶在内存中的存储空间是连续的（扩容过程中 或者 溢出桶较多时，可能会出现 正常桶 和 溢出桶 内存不连续的情况）。</p>
<h3><span id="334-读写操作">3.3.4 读写操作</span></h3><p>hashMap 的访问可以通过 下标、遍历 进行：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 访问 hashMap<br><span class="hljs-regexp">//</span> 下标访问，需要提前知道 key<br>_ = hash[key]<br><br><span class="hljs-regexp">//</span> 遍历访问，访问全部的 key-value<br><span class="hljs-keyword">for</span> k, v := range hash &#123;<br>    <span class="hljs-regexp">//</span> get k, v<br>&#125;<br></code></pre></td></tr></table></figure>

<p>两种方式对应到的 底层函数 以及 实现原理 完全不同。</p>
<p>在这一部分，重点看下 通过下标 访问(读) hashMap；<strong>遍历访问依赖了 range 关键字</strong></p>
<p>hashMap 的 写，一般指的是 增加、删除 和 修改，增加 和 修改字段都使用 index 和 赋值语句，删除 hashMap 使用到关键字 delete：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 增加</span><br>hash<span class="hljs-selector-attr">[key]</span> = value<br><span class="hljs-comment">// 修改</span><br>hash<span class="hljs-selector-attr">[key]</span> = newValue<br><span class="hljs-comment">// 删除</span><br><span class="hljs-function"><span class="hljs-title">delete</span><span class="hljs-params">(hash, key)</span></span><br></code></pre></td></tr></table></figure>

<p>读写 hashMap 的过程中，可能会引起 hashMap 的 <strong>扩容、缩容</strong>，能够更加深入的理解到 hashMap 存储数据的原理</p>
<h4><span id="访问-oindexmap">访问 – OINDEXMAP</span></h4><p>golang compile 类型检查期间，hash[key] 以及类似的操作会被转化为 hashMap 的 OINDEXMAP 操作</p>
<p>SSA 中间代码生成阶段会在 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/cmd/compile/internal/gc/walk.go#L1069">src/cmd/compile/internal/gc.walkexpr()</a> 函数中对 OINDEXMAP 操作进行转换：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> The result of walkexpr MUST be assigned back to n, e.g.<br><span class="hljs-regexp">//</span> 	n.Left = walkexpr(n.Left, init)<br><span class="hljs-keyword">func</span> walkexpr(n *Node, init *Nodes) *Node &#123;<br>    ......<br>    case OINDEXMAP:<br>		<span class="hljs-regexp">//</span> Replace m[k] with *map&#123;access1,assign&#125;(maptype, m, &amp;k)<br>		n.Left = walkexpr(n.Left, init)<br>		n.Right = walkexpr(n.Right, init)<br>		map_ := n.Left<br>		key := n.Right<br>		t := map_.Type<br>		<span class="hljs-regexp">//</span> 判断是 赋值 assignment 还是 访问 access<br>		<span class="hljs-keyword">if</span> n.IndexMapLValue() &#123;<br>		    <span class="hljs-regexp">//</span> m[k] = xxx   -&gt; 赋值语句<br>		    <span class="hljs-regexp">//</span> 通过 mkcall1() 将节点改写为 OCALL 节点<br>		    <span class="hljs-regexp">//</span> 调用的方法为 mapassign()<br>			<span class="hljs-regexp">//</span> This m[k] expression is on the left-hand side of an assignment.<br>			fast := mapfast(t)<br>			<span class="hljs-keyword">if</span> fast == mapslow &#123;<br>				<span class="hljs-regexp">//</span> standard version takes key by reference.<br>				<span class="hljs-regexp">//</span> order.expr made sure key is addressable.<br>				key = nod(OADDR, key, nil)<br>			&#125;<br>			n = mkcall1(mapfn(mapassign[fast], t), nil, init, typename(t), map_, key)<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>		    <span class="hljs-regexp">//</span> xxx := m[k]  -&gt;  访问语句<br>		    <span class="hljs-regexp">//</span> 通过 mkcall1() 将节点改写为 OCALL 节点<br>			<span class="hljs-regexp">//</span> m[k] is not the target of an assignment.<br>			fast := mapfast(t)<br>			<span class="hljs-keyword">if</span> fast == mapslow &#123;<br>				<span class="hljs-regexp">//</span> standard version takes key by reference.<br>				<span class="hljs-regexp">//</span> order.expr made sure key is addressable.<br>				key = nod(OADDR, key, nil)<br>			&#125;<br>            <br>            <span class="hljs-regexp">//</span> 判断接收参数的个数<br>			<span class="hljs-keyword">if</span> w := t.Elem().Width; w &lt;= zeroValSize &#123;<br>			    <span class="hljs-regexp">//</span> v := m[k] -&gt; 接受一个参数<br>			    <span class="hljs-regexp">//</span> 不需要获取 ok 标记 -&gt; 调用 mapaccess1()<br>				n = mkcall1(mapfn(mapaccess1[fast], t), types.NewPtr(t.Elem()), init, typename(t), map_, key)<br>			&#125; <span class="hljs-keyword">else</span> &#123;<br>			    <span class="hljs-regexp">//</span> v, ok := m[k] -&gt; 接受两个参数<br>			    <span class="hljs-regexp">//</span> 需要获取 ok 标记 -&gt; 调用 mapaccess2()<br>				z := zeroaddr(w)<br>				n = mkcall1(mapfn(<span class="hljs-string">&quot;mapaccess1_fat&quot;</span>, t), types.NewPtr(t.Elem()), init, typename(t), map_, key, z)<br>			&#125;<br>		&#125;<br>		n.Type = types.NewPtr(t.Elem())<br>		n.MarkNonNil() <span class="hljs-regexp">//</span> mapaccess1* and mapassign always return non-nil pointers.<br>		n = nod(ODEREF, n, nil)<br>		n.Type = t.Elem()<br>		n.SetTypecheck(<span class="hljs-number">1</span>)<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该函数执行逻辑为：</p>
<ol>
<li>首先根据 m[k] 和 赋值语句 := 的位置，来判断语句类型：赋值 assignment、访问 accessment</li>
<li>根据传入的参数个数，判断具体调用的 runtime 函数：runtime.mapaccess1(), runtime.mapaccess2()</li>
</ol>
<p>如下所示为，不同参数对应到的 运行时函数调用：</p>
<ol>
<li>当接受一个参数时，调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L394">runtime.mapaccess1()</a>，返回一个指向目标值的指针</li>
<li>当接受两个参数时，调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L452">runtime.mapaccess2()</a>，返回一个指向目标值的指针 以及 一个表示当前键对应的值是否存在的 bool 值<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 只获取值<br><span class="hljs-regexp">//</span> v := *mapaccess1(maptype, hash, &amp;key)<br>v := hash[key]<br><span class="hljs-regexp">//</span> 获取值 以及 ok 标记<br><span class="hljs-regexp">//</span> v, ok := *mapaccess2(maptype, hash, &amp;key)<br>v, ok := hash[key]<br></code></pre></td></tr></table></figure></li>
</ol>
<p><strong>runtime.mapaccess1()</strong><br>函数首先通过 hashMap 在初始化时设置的 hash Function、hashseed 计算得到当前 key 对应的 hash value</p>
<p>再通过 runtime.bucketMask() 和 runtime.add() 拿到该 key: value 所在的 桶序号<strong>（hash 低位）</strong> 和 tophash 的 8 位数字<strong>（hash 高 8 位）</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runtime.mapaccess1()</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapaccess1</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;<br>    ......<br>	alg := t.key.alg<br>	<span class="hljs-comment">// hash Function, hash seed 计算出 key 对应的 hash value</span><br>	hash := alg.hash(key, <span class="hljs-keyword">uintptr</span>(h.hash0))<br>	m := bucketMask(h.B)<br>	<span class="hljs-comment">// 定位到 hash 所在的 桶 -&gt; hash 低位</span><br>	<span class="hljs-comment">// add() 通过偏移量计算得到 桶的位置 b</span><br>	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>	<span class="hljs-comment">// 获取 hash 高 8 位</span><br>	top := tophash(hash)<br>bucketloop:<br>    <span class="hljs-comment">// 遍历 正常桶，然后遍历 溢出桶 overflow</span><br>	<span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br>		    <span class="hljs-comment">// 比较 tophash是否匹配</span><br>			<span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br>			    <span class="hljs-comment">// emptyRest -&gt; 桶的末尾，直接跳出，优化了查询速率</span><br>				<span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br>					<span class="hljs-keyword">break</span> bucketloop<br>				&#125;<br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>			<span class="hljs-comment">// tophash 匹配到</span><br>			k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-keyword">uintptr</span>(t.keysize))<br>			<span class="hljs-comment">// 判断 key 是否匹配；可能存在 tophash 相等，但是 key 不相等的情况</span><br>			<span class="hljs-keyword">if</span> alg.equal(key, k) &#123;<br>			    <span class="hljs-comment">// tophash, key 匹配后 -&gt; 获取 value</span><br>				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize)+i*<span class="hljs-keyword">uintptr</span>(t.valuesize))<br>				<span class="hljs-keyword">return</span> v<br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure>
<p>需要注意的是：hash Value 的低几位 用于 选择桶的序号，hash value 的高 8 位 用于桶内的比较，加速访问过程；这种设计能够减少同一个桶中有大量相等 tophash 的概率，进而提升效率。</p>
<p><strong>runtime.mapaccess2()</strong><br>runtime.mapaccess2() 在 runtime.mapaccess1() 的基础上，多返回了一个用于标识，键值是否存在的 bool 值：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runtime.mapaccess2()</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapaccess2</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="hljs-params">(unsafe.Pointer, <span class="hljs-keyword">bool</span>)</span></span> &#123;<br>    ......<br>	alg := t.key.alg<br>	<span class="hljs-comment">// hash Function, hash seed 计算出 key 对应的 hash value</span><br>	hash := alg.hash(key, <span class="hljs-keyword">uintptr</span>(h.hash0))<br>	m := bucketMask(h.B)<br>	<span class="hljs-comment">// 定位到 hash 所在的 桶 -&gt; hash 低位</span><br>	<span class="hljs-comment">// add() 通过偏移量计算得到 桶的位置 b</span><br>	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>	<span class="hljs-comment">// 获取 hash 高 8 位</span><br>	top := tophash(hash)<br>bucketloop:<br>    <span class="hljs-comment">// 遍历 正常桶，然后遍历 溢出桶 overflow</span><br>	<span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br>		    <span class="hljs-comment">// 比较 tophash是否匹配</span><br>			<span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br>			    <span class="hljs-comment">// emptyRest -&gt; 桶的末尾，直接跳出，优化了查询速率</span><br>				<span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br>					<span class="hljs-keyword">break</span> bucketloop<br>				&#125;<br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>			<span class="hljs-comment">// tophash 匹配到</span><br>			k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-keyword">uintptr</span>(t.keysize))<br>			<span class="hljs-comment">// 判断 key 是否匹配；可能存在 tophash 相等，但是 key 不相等的情况</span><br>			<span class="hljs-keyword">if</span> alg.equal(key, k) &#123;<br>			    <span class="hljs-comment">// tophash, key 匹配后 -&gt; 获取 value</span><br>				v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize)+i*<span class="hljs-keyword">uintptr</span>(t.valuesize))<br>				<span class="hljs-comment">// 匹配到，返回 v, true</span><br>				<span class="hljs-keyword">return</span> v, <span class="hljs-literal">true</span><br>			&#125;<br>		&#125;<br>	&#125;<br>	<span class="hljs-comment">// 未匹配到，返回 nil, false</span><br>	<span class="hljs-keyword">return</span> unsafe.Pointer(&amp;zeroVal[<span class="hljs-number">0</span>]), <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>通过布尔值 能够准确地知道，当 v == nil时，v 到底是哈希表中存储的元素 还是 该键对应的元素不存在（推荐使用这种方式）</p>
<p><strong>扩容过程中的访问</strong><br>golang 保证了在 hashMap 扩容期间，对 hashMap 的访问（参考 hashMap 扩容的实现）。</p>
<h4><span id="写入正常情况下的写入-oindexmap">写入（正常情况下的写入）- OINDEXMAP</span></h4><p>hashMap 的写入操作，可能会引起 hashMap 的扩容，正常情况下写入 以及 扩容过程中写入，实现逻辑有所不同。</p>
<p>在这一部分，只看正常情况下的 写入 hashMap 的操作</p>
<p>与 hashMap 的访问相同，golang compile 在类型检查期间，hash[key] 以及类似的操作会被转化为 hashMap 的 OINDEXMAP 操作</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 增加 key-value<br>hash[key] = value<br><span class="hljs-regexp">//</span> 更新 key-value<br>hash[key] = newValue<br></code></pre></td></tr></table></figure>

<p>SSA 中间代码生成阶段会在 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/cmd/compile/internal/gc/walk.go#L1069">src/cmd/compile/internal/gc.walkexpr()</a> 函数中对 OINDEXMAP 操作进行转换；当 hash[key] 出现在赋值符号 = 左侧时，会将其看做 对 hashMap 的写入：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// The result of walkexpr MUST be assigned back to n, e.g.</span><br><span class="hljs-comment">// 	n.Left = walkexpr(n.Left, init)</span><br>func walkexpr(n *Node, init *Nodes) *Node &#123;<br>    ......<br>    case OINDEXMAP:<br>		<span class="hljs-comment">// Replace m[k] with *map&#123;access1,assign&#125;(maptype, m, &amp;k)</span><br>		n<span class="hljs-selector-class">.Left</span> = walkexpr(n<span class="hljs-selector-class">.Left</span>, init)<br>		n<span class="hljs-selector-class">.Right</span> = walkexpr(n<span class="hljs-selector-class">.Right</span>, init)<br>		map_ := n<span class="hljs-selector-class">.Left</span><br>		key := n<span class="hljs-selector-class">.Right</span><br>		t := map_<span class="hljs-selector-class">.Type</span><br>		<span class="hljs-comment">// 判断是 赋值 assignment 还是 访问 access</span><br>		<span class="hljs-keyword">if</span> n<span class="hljs-selector-class">.IndexMapLValue</span>() &#123;<br>		    <span class="hljs-comment">// m[k] = xxx   -&gt; 赋值语句</span><br>		    <span class="hljs-comment">// 通过 mkcall1() 将节点改写为 OCALL 节点</span><br>		    <span class="hljs-comment">// 调用的方法为 mapassign()</span><br>			<span class="hljs-comment">// This m[k] expression is on the left-hand side of an assignment.</span><br>			fast := mapfast(t)<br>			<span class="hljs-keyword">if</span> fast == mapslow &#123;<br>				<span class="hljs-comment">// standard version takes key by reference.</span><br>				<span class="hljs-comment">// order.expr made sure key is addressable.</span><br>				key = nod(OADDR, key, nil)<br>			&#125;<br>			n = mkcall1(mapfn(mapassign<span class="hljs-selector-attr">[fast]</span>, t), nil, init, typename(t), map_, key)<br>		&#125; <span class="hljs-keyword">else</span> &#123;<br>		    <span class="hljs-comment">// xxx := m[k]  -&gt;  访问语句</span><br>		    <span class="hljs-comment">// 通过 mkcall1() 将节点改写为 OCALL 节点</span><br>			<span class="hljs-comment">// m[k] is not the target of an assignment.</span><br>            ......<br>		&#125;<br>		n<span class="hljs-selector-class">.Type</span> = types<span class="hljs-selector-class">.NewPtr</span>(t<span class="hljs-selector-class">.Elem</span>())<br>		n<span class="hljs-selector-class">.MarkNonNil</span>() <span class="hljs-comment">// mapaccess1* and mapassign always return non-nil pointers.</span><br>		n = nod(ODEREF, n, nil)<br>		n<span class="hljs-selector-class">.Type</span> = t<span class="hljs-selector-class">.Elem</span>()<br>		n<span class="hljs-selector-class">.SetTypecheck</span>(<span class="hljs-number">1</span>)<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure>

<p>经过 gc.walkexpr() 处理后，hashMap 的访问操作会被转换为 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L571">runtime.mapassign()</a> 函数的调用，由于代码较长，将其拆分为几个部分：</p>
<p>Step1: 函数根据传入的 key 计算出对应的 hash value, 进而确定 key 所在的 桶 buckets</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Like mapaccess, but allocates a slot for the key if it is not present in the map.</span><br><span class="hljs-comment">// 与 mapaccess() 实现相似，如果 key 不在当前的 map，会分配新的插槽，并将其插入到 map 中</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapassign</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;<br>    ......<br>	alg := t.key.alg<br>	<span class="hljs-comment">// 计算 key 的 hash</span><br>	hash := alg.hash(key, <span class="hljs-keyword">uintptr</span>(h.hash0))<br>    <br>    <span class="hljs-comment">// 标志位：hashWriting = 4</span><br>    <span class="hljs-comment">// 表示已经有一个 goroutine 在访问，会触发 panic：concurrent map writes</span><br>    <span class="hljs-comment">// 检测是否出现了 并发访问</span><br>	h.flags ^= hashWriting<br>    <br>again:<br>    <span class="hljs-comment">// 拿到 key 对应的桶的编号 -- 按位与</span><br>	bucket := hash &amp; bucketMask(h.B)<br>	<span class="hljs-comment">// 指针 和 偏移量 拿到 key 对应的桶</span><br>	b := (*bmap)(unsafe.Pointer(<span class="hljs-keyword">uintptr</span>(h.buckets) + bucket*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>	<span class="hljs-comment">// 计算 key 对应 hash 的高 8 位</span><br>	top := tophash(hash)<br></code></pre></td></tr></table></figure>

<p>Step2: 首先寻找 匹配的 key-value；遍历比较桶中存储的 tophash 和 key 计算得到的 hash，如果找到了相同结果，就返回目标地址的指针</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs awk">    var inserti *uint8          <span class="hljs-regexp">//</span> 指针，表示目标元素在桶中的索引<br>	var insertk unsafe.Pointer  <span class="hljs-regexp">//</span> key 的地址，寻址计算可以得到 key<br>	var val unsafe.Pointer      <span class="hljs-regexp">//</span> value 的地址，寻址计算可以得到 value<br>bucketloop:<br>	<span class="hljs-keyword">for</span> &#123;   <span class="hljs-regexp">//</span> 外层循环 -- 按照顺序遍历 正常桶 和 溢出桶 =&gt; 找到值之后，将其更新<br>		<span class="hljs-keyword">for</span> i := uintptr(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;   <span class="hljs-regexp">//</span> 内层循环 -- 按照顺序遍历当前桶的 tophash，key，value 值<br>			<span class="hljs-keyword">if</span> b.tophash[i] != top &#123;    <span class="hljs-regexp">//</span> key 的高 <span class="hljs-number">8</span> 位 hash 与 tophash 是否匹配<br>			    <span class="hljs-regexp">//</span> isEmpty(b.tophash[i]) == true =&gt; 当前位置的 tophash 为空<br>			    <span class="hljs-regexp">//</span> inserti == nil =&gt; inserti 只会赋值一次<br>			    <span class="hljs-regexp">//</span> 设计思想：<br>			    <span class="hljs-regexp">//</span> 在遍历的过程中，找到第一个空的位置，并对其进行记录<br>			    <span class="hljs-regexp">//</span> 便于后续的 插入新值 操作<br>				<span class="hljs-keyword">if</span> isEmpty(b.tophash[i]) &amp;&amp; inserti == nil &#123;<br>					inserti = &amp;b.tophash[i]<br>					insertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))<br>					val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))<br>				&#125;<br>				<span class="hljs-regexp">//</span> emptyRest =&gt; 该位置后的 key-value 都可用（不需要再往后遍历），提前结束当前桶的遍历<br>				<span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br>					<span class="hljs-keyword">break</span> bucketloop<br>				&#125;<br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>			<span class="hljs-regexp">//</span> 若匹配，先由 指针和偏移量 计算得到 完整的 k 值<br>			k := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))<br>			<span class="hljs-regexp">//</span> 再次判断，完整的 k 值是否与 key 相等<br>			<span class="hljs-regexp">//</span> 可能存在 tophash = key-hash，但是 value 不相等的情况<br>			<span class="hljs-keyword">if</span> !alg.equal(key, k) &#123;<br>				<span class="hljs-keyword">continue</span>    <span class="hljs-regexp">//</span> 若不等，继续当前桶的遍历<br>			&#125;<br>			<span class="hljs-regexp">//</span> k = key，匹配成功<br>			<span class="hljs-regexp">//</span> 通过 指针 和 偏移量 计算得到 value<br>			val = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))<br>			goto done   <span class="hljs-regexp">//</span> 跳转到 done，执行返回逻辑<br>		&#125;<br>		<span class="hljs-regexp">//</span> 当前桶匹配失败 =&gt; 到下一个桶中搜寻<br>		ovf := b.overflow(t)<br>		<span class="hljs-regexp">//</span> 判断是否存在溢出桶，若不存在溢出桶，跳出循环，执行写入操作<br>		<span class="hljs-keyword">if</span> ovf == nil &#123; <br>			<span class="hljs-keyword">break</span><br>		&#125;<br>		<span class="hljs-regexp">//</span> 存在溢出桶，继续遍历<br>		b = ovf<br>	&#125;<br></code></pre></td></tr></table></figure>

<p>Step3: 如果未找到匹配的 <code>key-value</code> =&gt; 插入新值</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs awk">    <span class="hljs-regexp">//</span> inserti == nil =&gt; 遍历过程中未找到空的位置 =&gt; 桶满<br>	<span class="hljs-keyword">if</span> inserti == nil &#123;<br>	    <span class="hljs-regexp">//</span> 通过 runtime.hmap.newoverflow() 创建新桶<br>	    <span class="hljs-regexp">//</span> or 使用 runtime.hmap 预先在 noverflow 中创建的溢出桶<br>		newb := h.newoverflow(t, b)<br>		<span class="hljs-regexp">//</span> 使用新桶中的第一个位置<br>		inserti = &amp;newb.tophash[<span class="hljs-number">0</span>]<br>		<span class="hljs-regexp">//</span> 指针和偏移量计算 insertk 和 val<br>		insertk = add(unsafe.Pointer(newb), dataOffset)<br>		val = add(insertk, bucketCnt*uintptr(t.keysize))<br>	&#125;<br><br>    <span class="hljs-regexp">//</span> inserti != nil =&gt; 桶中有空位，且 key-value 在 hashMap 中不存在<br>    <span class="hljs-regexp">//</span> 通过 runtime.typedmemmove() 将 key 移动到对应的空位<br>	typedmemmove(t.key, insertk, key)<br>	*inserti = top<br>	<span class="hljs-regexp">//</span> hashMap 元素数量 +<span class="hljs-number">1</span><br>	h.count++<br>    <br>    <span class="hljs-regexp">//</span> key-value 在 hashMap 中存在 =&gt; 返回 value 对应的地址<br>    <span class="hljs-regexp">//</span> 并没有进行真正的 赋值<br>done:<br>	return val<br>&#125;<br></code></pre></td></tr></table></figure>

<p>函数 <code>mapassign()</code> 返回的是 <code>val =&gt; value</code> 对应的地址，并没有真正的进行赋值。</p>
<p>真正的赋值操作是在编译期间插入的：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 将 字符串 <span class="hljs-number">88</span> 写到 hashMap 中<br>hashMap[key] = <span class="hljs-string">&quot;88&quot;</span><br><br><span class="hljs-regexp">//</span> 编译期间<br><span class="hljs-regexp">//</span> 调用 runtime.mapassign_fast64()<br><span class="hljs-number">00018</span> (+<span class="hljs-number">5</span>) CALL runtime.mapassign_fast64(SB)<br><span class="hljs-regexp">//</span> <span class="hljs-number">24</span>(SP) 为函数返回的值地址 val<br><span class="hljs-number">00020</span> (<span class="hljs-number">5</span>) MOVQ <span class="hljs-number">24</span>(SP), DI               ;; DI = &amp;value<br><span class="hljs-regexp">//</span> LEAQ 指令将 字符串的地址存储到 寄存器 AX 中<br><span class="hljs-number">00026</span> (<span class="hljs-number">5</span>) LEAQ go.string.<span class="hljs-string">&quot;88&quot;</span>(SB), AX   ;; AX = &amp;<span class="hljs-string">&quot;88&quot;</span><br><span class="hljs-regexp">//</span> MOVQ 指令将 字符串<span class="hljs-string">&quot;88&quot;</span> 存储到目标地址，完成写入<br><span class="hljs-number">00027</span> (<span class="hljs-number">5</span>) MOVQ AX, (DI)                 ;; *DI = AX<br></code></pre></td></tr></table></figure>

<p>在正常情况下（不涉及扩容），写入 <code>hashMap</code> 中元素时的流程描述为：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">一般情况：<br>1.根据key值，计算出<span class="hljs-built_in">hash</span>值<br>2.取<span class="hljs-built_in">hash</span>值低位与hmap.B取模来确定bucket的位置<br>3.取<span class="hljs-built_in">hash</span>值高位，在tophash数组中查询<br>4.如果tophash[i]中存储的<span class="hljs-built_in">hash</span>值与当前key的<span class="hljs-built_in">hash</span>值相同，则获取tophash[i]指向的key值进行比较，直接更新值<br>5.当前bucket没有找到，依次从溢出的bucket中寻找，找到后更新<br>6.如果未找到key，在bucket中寻找空余位置插入（源码中的设计是：找到顺序遍历的过程中第一个空余位置，或者新桶中的第一个位置）<br></code></pre></td></tr></table></figure>

<p>与 <code>hashMap</code> 的访问相同，需要考虑 扩容 过程中进行何种的设计和实现来保证哈希表的正常写入，相关的设计思想以及代码在分析 扩容 的过程中进行介绍。</p>
<h4><span id="扩容">扩容</span></h4><p>上一部分的 hashMap 读/写操作，只考虑了正常情况。随着 hashMap 中元素的逐渐增加，hashMap 的读写性能会恶化，所以我们需要更多的 bucket 和 更大的内存保证 hashMap 的读写性能：</p>
<p><strong>扩容条件</strong><br>在写入 hashMap 的 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L571">runtime.mapassign()</a> 函数，会在以下两种情况发生时触发 hashMap 的扩容，进而转到 扩容的入口 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L1026">runtime.hashGrow()</a>：</p>
<ol>
<li>负载因子 loadFactor &gt;= 6.5 -&gt; 平均每个 bucket 存储的 key:value 达到 6.5 个及以上</li>
<li>hashMap 使用了太多的溢出桶：overflow 数量大于 2^15 -&gt; overflow 数量超过 32768</li>
</ol>
<p>对应 <code>runtime.mapassign()</code> 源码如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// runtime.mapassign()</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapassign</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;<br><br>again:<br>    bucket := hash &amp; bucketMask(h.B)<br>	<span class="hljs-keyword">if</span> h.growing() &#123;<br>	    <span class="hljs-comment">// 数据的迁移由 growWork() 实际进行</span><br>		growWork(t, h, bucket)<br>	&#125;<br>	......<br>    <br>    ......<br><br>bucketloop:<br>	...<br>	<span class="hljs-comment">// !h.growing()：判断当前 hashMap 是否已经处于扩容状态，避免二次扩容</span><br>	<span class="hljs-comment">// overLoadFactor()：判断负载因子是否达到 6.5</span><br>	<span class="hljs-comment">// tooManyOverflowBuckets()：判断溢出桶的个数是否达到 2^15</span><br>	<span class="hljs-keyword">if</span> !h.growing() &amp;&amp; (overLoadFactor(h.count+<span class="hljs-number">1</span>, h.B) || tooManyOverflowBuckets(h.noverflow, h.B)) &#123;<br>	    <span class="hljs-comment">// 转到 扩容操作</span><br>	    <span class="hljs-comment">// runtime.hashGrow()</span><br>		hashGrow(t, h)<br>		<span class="hljs-comment">// hashMap 扩容后，跳转到 again</span><br>		<span class="hljs-comment">// 进行 数据迁移</span><br>		<span class="hljs-keyword">goto</span> again<br>	&#125;<br>	...<br>&#125;<br><br><span class="hljs-comment">// runtime.growWork()</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">growWork</span><span class="hljs-params">(t *maptype, h *hmap, bucket <span class="hljs-keyword">uintptr</span>)</span></span> &#123;<br>	<span class="hljs-comment">// make sure we evacuate the oldbucket corresponding</span><br>	<span class="hljs-comment">// to the bucket we&#x27;re about to use</span><br>	<span class="hljs-comment">// 实际调用了 runtime.evacuate() 去进行 数据迁移</span><br>	evacuate(t, h, bucket&amp;h.oldbucketmask())<br>    <br>	<span class="hljs-comment">// evacuate one more oldbucket to make progress on growing</span><br>	<span class="hljs-keyword">if</span> h.growing() &#123;<br>		evacuate(t, h, h.nevacuate)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>根据扩容的条件，分为了两种不同的扩容方式：</p>
<ol>
<li>等量扩容：溢出桶太多导致 sameSizeGrow()；一旦 hashMap 中出现了过多的溢出桶，会创建 <strong>与当前桶相同数量的</strong> 新桶保存数据，gc 会清理老的溢出桶，释放内存</li>
<li>增量扩容：loadFactor 达到了阈值，会创建 <strong>当前桶双倍数量的</strong> 新桶，oldBucket 中的数据会疏散到 newBucket 中<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs roboconf">// func hashGrow()<br>func hashGrow(t *maptype, h *hmap) &#123;<br>	<span class="hljs-attribute">bigger</span> := uint8(1)<br>	if !overLoadFactor(h<span class="hljs-variable">.count</span>+1, h<span class="hljs-variable">.B</span>) &#123;<br>		bigger = 0<br>		h<span class="hljs-variable">.flags</span> |= sameSizeGrow<br>	&#125;<br>	oldbuckets := h<span class="hljs-variable">.buckets</span><br>	// makeBucketArray() 创建新的桶<br>	newbuckets, nextOverflow := makeBucketArray(t, h<span class="hljs-variable">.B</span>+bigger, nil)<br><br>	h<span class="hljs-variable">.B</span> += bigger<br>	h<span class="hljs-variable">.flags</span> = flags<br>	// 指向 旧桶<br>	h<span class="hljs-variable">.oldbuckets</span> = oldbuckets<br>	// 指向 新桶<br>	h<span class="hljs-variable">.buckets</span> = newbuckets<br>	h<span class="hljs-variable">.nevacuate</span> = 0<br>	h<span class="hljs-variable">.noverflow</span> = 0<br>    // 指向旧的 溢出桶<br>	h<span class="hljs-variable">.extra</span><span class="hljs-variable">.oldoverflow</span> = h<span class="hljs-variable">.extra</span><span class="hljs-variable">.overflow</span><br>	h<span class="hljs-variable">.extra</span><span class="hljs-variable">.overflow</span> = nil<br>	// 指向新的 溢出桶<br>	h<span class="hljs-variable">.extra</span><span class="hljs-variable">.nextOverflow</span> = nextOverflow<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p>在 runtime.hashGrow() 中，看不出 两种扩容方式的区别，该函数只是创建了新的桶，并没有对数据进行拷贝和转移。</p>
<p>通过分析以上代码可知，拷贝和迁移数据的过程是在 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/ac0ba6707c1655ea4316b41d06571a0303cc60eb/src/runtime/map.go#L1137">runtime.evacuate()</a> 中完成的，对传入桶中的元素进行再分配：</p>
<p>对于增量扩容的 case，hashMap 容量翻倍，每个旧桶中的元素会都分流到新创建的两个桶中：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// func evacuate()</span><br>func evacuate(t *maptype, h *hmap, oldbucket uintptr) &#123;<br>	<span class="hljs-selector-tag">b</span> := (*bmap)(add(h<span class="hljs-selector-class">.oldbuckets</span>, oldbucket*uintptr(t.bucketsize)))<br>	newbit := h<span class="hljs-selector-class">.noldbuckets</span>()<br>	<span class="hljs-keyword">if</span> !evacuated(b) &#123;<br>	    <span class="hljs-comment">// runtime.evacDst 结构体</span><br>	    <span class="hljs-comment">// 保存分配上下文</span><br>	    <span class="hljs-comment">// 记录 分流 到 新桶 的位置</span><br>		<span class="hljs-selector-tag">var</span> xy <span class="hljs-selector-attr">[2]</span>evacDst<br>		<span class="hljs-comment">// 增量扩容，将一个旧桶中的数据，分流到两个新桶</span><br>		<span class="hljs-comment">// x -&gt; oldBucket 第一个数据</span><br>		<span class="hljs-comment">// 分流到新桶 xy[0]</span><br>		x := &amp;xy<span class="hljs-selector-attr">[0]</span><br>		x<span class="hljs-selector-class">.b</span> = (*bmap)(add(h<span class="hljs-selector-class">.buckets</span>, oldbucket*uintptr(t.bucketsize)))<br>		x<span class="hljs-selector-class">.k</span> = add(unsafe<span class="hljs-selector-class">.Pointer</span>(x.b), dataOffset)<br>		x<span class="hljs-selector-class">.v</span> = add(x<span class="hljs-selector-class">.k</span>, bucketCnt*uintptr(t.keysize))<br>        <br>        <span class="hljs-comment">// y -&gt; oldBucket 第二个数据</span><br>        <span class="hljs-comment">// 分流到新桶 xy[1]</span><br>		y := &amp;xy<span class="hljs-selector-attr">[1]</span><br>		y<span class="hljs-selector-class">.b</span> = (*bmap)(add(h<span class="hljs-selector-class">.buckets</span>, (oldbucket+newbit)*uintptr(t.bucketsize)))<br>		y<span class="hljs-selector-class">.k</span> = add(unsafe<span class="hljs-selector-class">.Pointer</span>(y.b), dataOffset)<br>		y<span class="hljs-selector-class">.v</span> = add(y<span class="hljs-selector-class">.k</span>, bucketCnt*uintptr(t.keysize))<br></code></pre></td></tr></table></figure>

<p>对于 等量扩容，<strong>桶的数量未变</strong>，旧桶与新桶是一对一的关系；可以看做重新做了一遍 增量扩容操作， 把松散的键值对重新排列一次，使得 bucket 的利用率更高：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go">        ....<br>        <span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;<br>			k := add(unsafe.Pointer(b), dataOffset)<br>			v := add(k, bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize))<br>			<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; bucketCnt; i, k, v = i+<span class="hljs-number">1</span>, add(k, <span class="hljs-keyword">uintptr</span>(t.keysize)), add(v, <span class="hljs-keyword">uintptr</span>(t.valuesize)) &#123;<br>				top := b.tophash[i]<br>				k2 := k<br>				<span class="hljs-keyword">var</span> useY <span class="hljs-keyword">uint8</span><br>				hash := t.key.alg.hash(k2, <span class="hljs-keyword">uintptr</span>(h.hash0))<br>				<span class="hljs-keyword">if</span> hash&amp;newbit != <span class="hljs-number">0</span> &#123;<br>					useY = <span class="hljs-number">1</span><br>				&#125;<br>				b.tophash[i] = evacuatedX + useY<br>				<span class="hljs-comment">// 只使用了 xy[0] 或者 xy[1]</span><br>				dst := &amp;xy[useY]<br><br>				<span class="hljs-keyword">if</span> dst.i == bucketCnt &#123;<br>					dst.b = h.newoverflow(t, dst.b)<br>					dst.i = <span class="hljs-number">0</span><br>					dst.k = add(unsafe.Pointer(dst.b), dataOffset)<br>					dst.v = add(dst.k, bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize))<br>				&#125;<br>				dst.b.tophash[dst.i&amp;(bucketCnt<span class="hljs-number">-1</span>)] = top<br>				<span class="hljs-comment">// 将 key, value 写入到 新的桶</span><br>				typedmemmove(t.key, dst.k, k)<br>				typedmemmove(t.elem, dst.v, v)<br>				dst.i++<br>				dst.k = add(dst.k, <span class="hljs-keyword">uintptr</span>(t.keysize))<br>				dst.v = add(dst.v, <span class="hljs-keyword">uintptr</span>(t.valuesize))<br>			&#125;<br>		&#125;<br>		...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>runtime.evacuate() 最后调用 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L1242">runtime.advanceEvacuationMark()</a> 增加 hashMap 的 nevacuate 计数器（nevacuate=1 迁移完成），并在所有的旧桶 oldBuckets 都被分流后，清空 hashMap 的 oldbuckets 和 oldoverflow</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// runtime.advanceEvacuationMark()</span><br>func advanceEvacuationMark(h *hmap, t *maptype, <span class="hljs-keyword">new</span><span class="hljs-type">bit</span> uintptr) &#123;<br>	h.nevacuate++<br>	<span class="hljs-comment">// Experiments suggest that 1024 is overkill by at least an order of magnitude.</span><br>	<span class="hljs-comment">// Put it in there as a safeguard anyway, to ensure O(1) behavior.</span><br>	stop :<span class="hljs-type"></span>= h.nevacuate + <span class="hljs-number">1024</span><br>	<span class="hljs-keyword">if</span> stop &gt; <span class="hljs-keyword">new</span><span class="hljs-type">bit</span> &#123;<br>		stop = <span class="hljs-keyword">new</span><span class="hljs-type">bit</span><br>	&#125;<br>	<span class="hljs-keyword">for</span> h.nevacuate != stop &amp;&amp; bucketEvacuated(t, h, h.nevacuate) &#123;<br>		h.nevacuate++<br>	&#125;<br>	<span class="hljs-keyword">if</span> h.nevacuate == <span class="hljs-keyword">new</span><span class="hljs-type">bit</span> &#123; <span class="hljs-comment">// newbit == # of oldbuckets</span><br>		<span class="hljs-comment">// Growing is all done. Free old main bucket array.</span><br>		h.oldbuckets = nil<br>		<span class="hljs-comment">// Can discard old overflow buckets as well.</span><br>		<span class="hljs-comment">// If they are still referenced by an iterator,</span><br>		<span class="hljs-comment">// then the iterator holds a pointers to the slice.</span><br>		<span class="hljs-keyword">if</span> h.extra != nil &#123;<br>			h.extra.oldoverflow = nil<br>		&#125;<br>		h.flags &amp;^= sameSizeGrow<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>hashMap 扩容中的访问 runtime.mapaccess1()</strong><br>当前 hashMap 处于扩容状态时，oldbucket != nil -&gt; 定位到旧桶，并在该桶没有被分流时，从中获取 key:value；若未找到，就去新桶 newbucket 中找：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapaccess1</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span> <span class="hljs-title">unsafe</span>.<span class="hljs-title">Pointer</span></span> &#123;<br>	...<br>	alg := t.key.alg<br>	hash := alg.hash(key, <span class="hljs-keyword">uintptr</span>(h.hash0))<br>	m := bucketMask(h.B)<br>	b := (*bmap)(add(h.buckets, (hash&amp;m)*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>	<span class="hljs-comment">// 旧桶 oldbuckets 存在</span><br>	<span class="hljs-keyword">if</span> c := h.oldbuckets; c != <span class="hljs-literal">nil</span> &#123;<br>		<span class="hljs-keyword">if</span> !h.sameSizeGrow() &#123;<br>			m &gt;&gt;= <span class="hljs-number">1</span><br>		&#125;<br>		oldb := (*bmap)(add(c, (hash&amp;m)*<span class="hljs-keyword">uintptr</span>(t.bucketsize)))<br>		<span class="hljs-keyword">if</span> !evacuated(oldb) &#123;<br>			b = oldb<br>		&#125;<br>	&#125;<br>bucketloop:<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>hashMap 扩容中的写入 runtime.mapassign()</strong><br>当前 hashMap 正处于扩容状态时，<strong>每次向 hashMap 写入值时，都会触发 runtime.growWork() 增量拷贝哈希表的内容</strong>：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">func</span> mapassign(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer &#123;<br>	...<br>again:<br>    <span class="hljs-regexp">//</span> 定位到 桶<br>	bucket := hash &amp; bucketMask(h.B)<br>	<span class="hljs-keyword">if</span> h.growing() &#123;<br>	    <span class="hljs-regexp">//</span> 若当前 hashMap 正在扩容，增量拷贝<br>		growWork(t, h, bucket)<br>	&#125;<br>	...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>除了写入操作之外，删除操作也会在哈希表扩容期间触发 runtime.growWork，触发的方式和代码与这里的逻辑几乎完全相同，都是计算当前值所在的桶，然后拷贝桶中的元素。</p>
<h4><span id="删除-delete-odelete">删除 – delete() – ODELETE</span></h4><p>在编译期间，delete() 会被转换为 ODELETE 节点，<a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/cmd/compile/internal/gc/walk.go#L771">src/cmd/compile/internal/gc.walkexpr()</a> 会将 ODELETE 节点转换成 runtime.mapdelete(), mapdelete_faststr(), mapdelete_fast32() 和 mapdelete_fast64() 中的一个</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">// runtime.walkexpr()</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkexpr</span>(n <span class="hljs-operator">*</span><span class="hljs-type">Node</span>, <span class="hljs-keyword">init</span> <span class="hljs-operator">*</span><span class="hljs-type">Nodes</span>)</span> <span class="hljs-operator">*</span><span class="hljs-type">Node</span> &#123;<br>    <span class="hljs-operator">......</span><br>	<span class="hljs-keyword">switch</span> n.<span class="hljs-type">Op</span> &#123;<br>	<span class="hljs-keyword">case</span> <span class="hljs-type">ODELETE</span>:<br>		<span class="hljs-keyword">init</span>.<span class="hljs-type">AppendNodes</span>(<span class="hljs-operator">&amp;</span>n.<span class="hljs-type">Ninit</span>)<br>		map_ :<span class="hljs-operator">=</span> n.<span class="hljs-type">List</span>.<span class="hljs-type">First</span>()<br>		key :<span class="hljs-operator">=</span> n.<span class="hljs-type">List</span>.<span class="hljs-type">Second</span>()<br>		map_ <span class="hljs-operator">=</span> walkexpr(map_, <span class="hljs-keyword">init</span>)<br>		key <span class="hljs-operator">=</span> walkexpr(key, <span class="hljs-keyword">init</span>)<br><br>		t :<span class="hljs-operator">=</span> map_.<span class="hljs-keyword">Type</span><br>		fast :<span class="hljs-operator">=</span> mapfast(t)<br>		<span class="hljs-keyword">if</span> fast <span class="hljs-operator">==</span> mapslow &#123;<br>			key <span class="hljs-operator">=</span> nod(<span class="hljs-type">OADDR</span>, key, <span class="hljs-literal">nil</span>)<br>		&#125;<br>		<span class="hljs-comment">// 调用 mkcall1() 替换为 OCALL 节点</span><br>		<span class="hljs-comment">// 实际调用的函数为 runtime.mapfndel()</span><br>		n <span class="hljs-operator">=</span> mkcall1(mapfndel(mapdelete[fast], t), <span class="hljs-literal">nil</span>, <span class="hljs-keyword">init</span>, typename(t), map_, key)<br>	&#125;<br>	<span class="hljs-operator">......</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>以 <a target="_blank" rel="noopener" href="https://github.com/golang/go/blob/36f30ba289e31df033d100b2adb4eaf557f05a34/src/runtime/map.go#L685">runtime.mapdelete()</a> 为例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mapdelete</span><span class="hljs-params">(t *maptype, h *hmap, key unsafe.Pointer)</span></span> &#123;<br>	...<br>	<span class="hljs-keyword">if</span> h.growing() &#123;<br>		growWork(t, h, bucket)<br>	&#125;<br>	...<br>search:<br>	<span class="hljs-keyword">for</span> ; b != <span class="hljs-literal">nil</span>; b = b.overflow(t) &#123;<br>		<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">uintptr</span>(<span class="hljs-number">0</span>); i &lt; bucketCnt; i++ &#123;<br>			<span class="hljs-keyword">if</span> b.tophash[i] != top &#123;<br>				<span class="hljs-keyword">if</span> b.tophash[i] == emptyRest &#123;<br>					<span class="hljs-keyword">break</span> search<br>				&#125;<br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>			k := add(unsafe.Pointer(b), dataOffset+i*<span class="hljs-keyword">uintptr</span>(t.keysize))<br>			k2 := k<br>			<span class="hljs-keyword">if</span> !alg.equal(key, k2) &#123;<br>				<span class="hljs-keyword">continue</span><br>			&#125;<br>			*(*unsafe.Pointer)(k) = <span class="hljs-literal">nil</span><br>			v := add(unsafe.Pointer(b), dataOffset+bucketCnt*<span class="hljs-keyword">uintptr</span>(t.keysize)+i*<span class="hljs-keyword">uintptr</span>(t.valuesize))<br>			*(*unsafe.Pointer)(v) = <span class="hljs-literal">nil</span><br>			b.tophash[i] = emptyOne<br>			...<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>哈希表的删除逻辑与写入逻辑很相似，只是触发哈希的删除需要使用关键字，如果在删除期间遇到了哈希表的扩容，就会分流桶中的元素，分流结束之后会找到桶中的目标元素完成键值对的删除工作。</p>
<h3><span id="conclusion">Conclusion</span></h3><ol>
<li>sameGrow 机制，在溢出桶较多时，整理 hashMap 的内存，减少空间的占用</li>
<li>扩容机制的实现 -&gt; 增量，在写入、删除时 顺带迁移数据</li>
<li>扩容过程中的读、写、删除逻辑</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Golang/">Golang</a>
                    
                      <a class="hover-with-bg" href="/categories/Golang/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/">读书笔记</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E3%80%8AGo%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E3%80%8B/">《Go语言设计与实现》</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/12/30/3-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%88%87%E7%89%87-Slice/">
                        <span class="hidden-mobile">3.2 数据结构 -- 切片 Slice</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"0SrF373pw8HzuOT402REPdE9-gzGzoHsz","appKey":"PijYR5FjJEAiikcHPtF712qM","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          Fluid.plugins.initFancyBox('#valine .vcontent img:not(.vemoji)');
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
